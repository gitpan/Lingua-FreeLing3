# This file was automatically generated by SWIG (http://www.swig.org).
# Version 2.0.11
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

package Lingua::FreeLing3::Bindings;
use base qw(Exporter);
use base qw(DynaLoader);
package Lingua::FreeLing3::Bindingsc;
bootstrap Lingua::FreeLing3::Bindings;
package Lingua::FreeLing3::Bindings;
@EXPORT = qw();

# ---------- BASE METHODS -------------

package Lingua::FreeLing3::Bindings;

sub TIEHASH {
    my ($classname,$obj) = @_;
    return bless $obj, $classname;
}

sub CLEAR { }

sub FIRSTKEY { }

sub NEXTKEY { }

sub FETCH {
    my ($self,$field) = @_;
    my $member_func = "swig_${field}_get";
    $self->$member_func();
}

sub STORE {
    my ($self,$field,$newval) = @_;
    my $member_func = "swig_${field}_set";
    $self->$member_func($newval);
}

sub this {
    my $ptr = shift;
    return tied(%$ptr);
}


# ------- FUNCTION WRAPPERS --------

package Lingua::FreeLing3::Bindings;


############# Class : Lingua::FreeLing3::Bindings::VectorWord ##############

package Lingua::FreeLing3::Bindings::VectorWord;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Lingua::FreeLing3::Bindings );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Lingua::FreeLing3::Bindingsc::new_VectorWord(@_);
    bless $self, $pkg if defined($self);
}

*size = *Lingua::FreeLing3::Bindingsc::VectorWord_size;
*empty = *Lingua::FreeLing3::Bindingsc::VectorWord_empty;
*clear = *Lingua::FreeLing3::Bindingsc::VectorWord_clear;
*push = *Lingua::FreeLing3::Bindingsc::VectorWord_push;
*pop = *Lingua::FreeLing3::Bindingsc::VectorWord_pop;
*get = *Lingua::FreeLing3::Bindingsc::VectorWord_get;
*set = *Lingua::FreeLing3::Bindingsc::VectorWord_set;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Lingua::FreeLing3::Bindingsc::delete_VectorWord($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Lingua::FreeLing3::Bindings::ListWord ##############

package Lingua::FreeLing3::Bindings::ListWord;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Lingua::FreeLing3::Bindings );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Lingua::FreeLing3::Bindingsc::new_ListWord(@_);
    bless $self, $pkg if defined($self);
}

*size = *Lingua::FreeLing3::Bindingsc::ListWord_size;
*empty = *Lingua::FreeLing3::Bindingsc::ListWord_empty;
*clear = *Lingua::FreeLing3::Bindingsc::ListWord_clear;
*push = *Lingua::FreeLing3::Bindingsc::ListWord_push;
*elements = *Lingua::FreeLing3::Bindingsc::ListWord_elements;
*get = *Lingua::FreeLing3::Bindingsc::ListWord_get;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Lingua::FreeLing3::Bindingsc::delete_ListWord($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Lingua::FreeLing3::Bindings::ListAnalysis ##############

package Lingua::FreeLing3::Bindings::ListAnalysis;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Lingua::FreeLing3::Bindings );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Lingua::FreeLing3::Bindingsc::new_ListAnalysis(@_);
    bless $self, $pkg if defined($self);
}

*size = *Lingua::FreeLing3::Bindingsc::ListAnalysis_size;
*empty = *Lingua::FreeLing3::Bindingsc::ListAnalysis_empty;
*clear = *Lingua::FreeLing3::Bindingsc::ListAnalysis_clear;
*push = *Lingua::FreeLing3::Bindingsc::ListAnalysis_push;
*elements = *Lingua::FreeLing3::Bindingsc::ListAnalysis_elements;
*get = *Lingua::FreeLing3::Bindingsc::ListAnalysis_get;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Lingua::FreeLing3::Bindingsc::delete_ListAnalysis($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Lingua::FreeLing3::Bindings::ListSentence ##############

package Lingua::FreeLing3::Bindings::ListSentence;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Lingua::FreeLing3::Bindings );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Lingua::FreeLing3::Bindingsc::new_ListSentence(@_);
    bless $self, $pkg if defined($self);
}

*size = *Lingua::FreeLing3::Bindingsc::ListSentence_size;
*empty = *Lingua::FreeLing3::Bindingsc::ListSentence_empty;
*clear = *Lingua::FreeLing3::Bindingsc::ListSentence_clear;
*push = *Lingua::FreeLing3::Bindingsc::ListSentence_push;
*elements = *Lingua::FreeLing3::Bindingsc::ListSentence_elements;
*get = *Lingua::FreeLing3::Bindingsc::ListSentence_get;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Lingua::FreeLing3::Bindingsc::delete_ListSentence($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Lingua::FreeLing3::Bindings::ListParagraph ##############

package Lingua::FreeLing3::Bindings::ListParagraph;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Lingua::FreeLing3::Bindings );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Lingua::FreeLing3::Bindingsc::new_ListParagraph(@_);
    bless $self, $pkg if defined($self);
}

*size = *Lingua::FreeLing3::Bindingsc::ListParagraph_size;
*empty = *Lingua::FreeLing3::Bindingsc::ListParagraph_empty;
*clear = *Lingua::FreeLing3::Bindingsc::ListParagraph_clear;
*push = *Lingua::FreeLing3::Bindingsc::ListParagraph_push;
*elements = *Lingua::FreeLing3::Bindingsc::ListParagraph_elements;
*get = *Lingua::FreeLing3::Bindingsc::ListParagraph_get;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Lingua::FreeLing3::Bindingsc::delete_ListParagraph($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Lingua::FreeLing3::Bindings::ListString ##############

package Lingua::FreeLing3::Bindings::ListString;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Lingua::FreeLing3::Bindings );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Lingua::FreeLing3::Bindingsc::new_ListString(@_);
    bless $self, $pkg if defined($self);
}

*size = *Lingua::FreeLing3::Bindingsc::ListString_size;
*empty = *Lingua::FreeLing3::Bindingsc::ListString_empty;
*clear = *Lingua::FreeLing3::Bindingsc::ListString_clear;
*push = *Lingua::FreeLing3::Bindingsc::ListString_push;
*elements = *Lingua::FreeLing3::Bindingsc::ListString_elements;
*get = *Lingua::FreeLing3::Bindingsc::ListString_get;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Lingua::FreeLing3::Bindingsc::delete_ListString($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Lingua::FreeLing3::Bindings::ListInt ##############

package Lingua::FreeLing3::Bindings::ListInt;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Lingua::FreeLing3::Bindings );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Lingua::FreeLing3::Bindingsc::new_ListInt(@_);
    bless $self, $pkg if defined($self);
}

*size = *Lingua::FreeLing3::Bindingsc::ListInt_size;
*empty = *Lingua::FreeLing3::Bindingsc::ListInt_empty;
*clear = *Lingua::FreeLing3::Bindingsc::ListInt_clear;
*push = *Lingua::FreeLing3::Bindingsc::ListInt_push;
*elements = *Lingua::FreeLing3::Bindingsc::ListInt_elements;
*get = *Lingua::FreeLing3::Bindingsc::ListInt_get;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Lingua::FreeLing3::Bindingsc::delete_ListInt($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Lingua::FreeLing3::Bindings::VectorListInt ##############

package Lingua::FreeLing3::Bindings::VectorListInt;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Lingua::FreeLing3::Bindings );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Lingua::FreeLing3::Bindingsc::new_VectorListInt(@_);
    bless $self, $pkg if defined($self);
}

*size = *Lingua::FreeLing3::Bindingsc::VectorListInt_size;
*empty = *Lingua::FreeLing3::Bindingsc::VectorListInt_empty;
*clear = *Lingua::FreeLing3::Bindingsc::VectorListInt_clear;
*push = *Lingua::FreeLing3::Bindingsc::VectorListInt_push;
*pop = *Lingua::FreeLing3::Bindingsc::VectorListInt_pop;
*get = *Lingua::FreeLing3::Bindingsc::VectorListInt_get;
*set = *Lingua::FreeLing3::Bindingsc::VectorListInt_set;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Lingua::FreeLing3::Bindingsc::delete_VectorListInt($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Lingua::FreeLing3::Bindings::VectorListString ##############

package Lingua::FreeLing3::Bindings::VectorListString;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Lingua::FreeLing3::Bindings );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Lingua::FreeLing3::Bindingsc::new_VectorListString(@_);
    bless $self, $pkg if defined($self);
}

*size = *Lingua::FreeLing3::Bindingsc::VectorListString_size;
*empty = *Lingua::FreeLing3::Bindingsc::VectorListString_empty;
*clear = *Lingua::FreeLing3::Bindingsc::VectorListString_clear;
*push = *Lingua::FreeLing3::Bindingsc::VectorListString_push;
*pop = *Lingua::FreeLing3::Bindingsc::VectorListString_pop;
*get = *Lingua::FreeLing3::Bindingsc::VectorListString_get;
*set = *Lingua::FreeLing3::Bindingsc::VectorListString_set;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Lingua::FreeLing3::Bindingsc::delete_VectorListString($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Lingua::FreeLing3::Bindings::VectorString ##############

package Lingua::FreeLing3::Bindings::VectorString;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Lingua::FreeLing3::Bindings );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Lingua::FreeLing3::Bindingsc::new_VectorString(@_);
    bless $self, $pkg if defined($self);
}

*size = *Lingua::FreeLing3::Bindingsc::VectorString_size;
*empty = *Lingua::FreeLing3::Bindingsc::VectorString_empty;
*clear = *Lingua::FreeLing3::Bindingsc::VectorString_clear;
*push = *Lingua::FreeLing3::Bindingsc::VectorString_push;
*pop = *Lingua::FreeLing3::Bindingsc::VectorString_pop;
*get = *Lingua::FreeLing3::Bindingsc::VectorString_get;
*set = *Lingua::FreeLing3::Bindingsc::VectorString_set;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Lingua::FreeLing3::Bindingsc::delete_VectorString($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Lingua::FreeLing3::Bindings::PairDoubleString ##############

package Lingua::FreeLing3::Bindings::PairDoubleString;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Lingua::FreeLing3::Bindings );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Lingua::FreeLing3::Bindingsc::new_PairDoubleString(@_);
    bless $self, $pkg if defined($self);
}

*swig_first_get = *Lingua::FreeLing3::Bindingsc::PairDoubleString_first_get;
*swig_first_set = *Lingua::FreeLing3::Bindingsc::PairDoubleString_first_set;
*swig_second_get = *Lingua::FreeLing3::Bindingsc::PairDoubleString_second_get;
*swig_second_set = *Lingua::FreeLing3::Bindingsc::PairDoubleString_second_set;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Lingua::FreeLing3::Bindingsc::delete_PairDoubleString($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Lingua::FreeLing3::Bindings::VectorPairDoubleString ##############

package Lingua::FreeLing3::Bindings::VectorPairDoubleString;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Lingua::FreeLing3::Bindings );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Lingua::FreeLing3::Bindingsc::new_VectorPairDoubleString(@_);
    bless $self, $pkg if defined($self);
}

*size = *Lingua::FreeLing3::Bindingsc::VectorPairDoubleString_size;
*empty = *Lingua::FreeLing3::Bindingsc::VectorPairDoubleString_empty;
*clear = *Lingua::FreeLing3::Bindingsc::VectorPairDoubleString_clear;
*push = *Lingua::FreeLing3::Bindingsc::VectorPairDoubleString_push;
*pop = *Lingua::FreeLing3::Bindingsc::VectorPairDoubleString_pop;
*get = *Lingua::FreeLing3::Bindingsc::VectorPairDoubleString_get;
*set = *Lingua::FreeLing3::Bindingsc::VectorPairDoubleString_set;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Lingua::FreeLing3::Bindingsc::delete_VectorPairDoubleString($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Lingua::FreeLing3::Bindings::PairStringString ##############

package Lingua::FreeLing3::Bindings::PairStringString;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Lingua::FreeLing3::Bindings );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Lingua::FreeLing3::Bindingsc::new_PairStringString(@_);
    bless $self, $pkg if defined($self);
}

*swig_first_get = *Lingua::FreeLing3::Bindingsc::PairStringString_first_get;
*swig_first_set = *Lingua::FreeLing3::Bindingsc::PairStringString_first_set;
*swig_second_get = *Lingua::FreeLing3::Bindingsc::PairStringString_second_get;
*swig_second_set = *Lingua::FreeLing3::Bindingsc::PairStringString_second_set;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Lingua::FreeLing3::Bindingsc::delete_PairStringString($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Lingua::FreeLing3::Bindings::VectorPairStringString ##############

package Lingua::FreeLing3::Bindings::VectorPairStringString;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Lingua::FreeLing3::Bindings );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Lingua::FreeLing3::Bindingsc::new_VectorPairStringString(@_);
    bless $self, $pkg if defined($self);
}

*size = *Lingua::FreeLing3::Bindingsc::VectorPairStringString_size;
*empty = *Lingua::FreeLing3::Bindingsc::VectorPairStringString_empty;
*clear = *Lingua::FreeLing3::Bindingsc::VectorPairStringString_clear;
*push = *Lingua::FreeLing3::Bindingsc::VectorPairStringString_push;
*pop = *Lingua::FreeLing3::Bindingsc::VectorPairStringString_pop;
*get = *Lingua::FreeLing3::Bindingsc::VectorPairStringString_get;
*set = *Lingua::FreeLing3::Bindingsc::VectorPairStringString_set;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Lingua::FreeLing3::Bindingsc::delete_VectorPairStringString($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Lingua::FreeLing3::Bindings::TreeIteratorNode ##############

package Lingua::FreeLing3::Bindings::TreeIteratorNode;
use overload
    "!=" => sub { $_[0]->__ne__($_[1])},
    "==" => sub { $_[0]->__eq__($_[1])},
    "=" => sub { my $class = ref($_[0]); $class->new($_[0]) },
    "fallback" => 1;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Lingua::FreeLing3::Bindings );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Lingua::FreeLing3::Bindingsc::new_TreeIteratorNode(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Lingua::FreeLing3::Bindingsc::delete_TreeIteratorNode($self);
        delete $OWNER{$self};
    }
}

*__ref__ = *Lingua::FreeLing3::Bindingsc::TreeIteratorNode___ref__;
*__deref__ = *Lingua::FreeLing3::Bindingsc::TreeIteratorNode___deref__;
*__eq__ = *Lingua::FreeLing3::Bindingsc::TreeIteratorNode___eq__;
*__ne__ = *Lingua::FreeLing3::Bindingsc::TreeIteratorNode___ne__;
*swig_info_get = *Lingua::FreeLing3::Bindingsc::TreeIteratorNode_info_get;
*swig_info_set = *Lingua::FreeLing3::Bindingsc::TreeIteratorNode_info_set;
*num_children = *Lingua::FreeLing3::Bindingsc::TreeIteratorNode_num_children;
*nth_child = *Lingua::FreeLing3::Bindingsc::TreeIteratorNode_nth_child;
*get_parent = *Lingua::FreeLing3::Bindingsc::TreeIteratorNode_get_parent;
*nth_child_ref = *Lingua::FreeLing3::Bindingsc::TreeIteratorNode_nth_child_ref;
*empty = *Lingua::FreeLing3::Bindingsc::TreeIteratorNode_empty;
*sibling_begin = *Lingua::FreeLing3::Bindingsc::TreeIteratorNode_sibling_begin;
*sibling_end = *Lingua::FreeLing3::Bindingsc::TreeIteratorNode_sibling_end;
*sibling_rbegin = *Lingua::FreeLing3::Bindingsc::TreeIteratorNode_sibling_rbegin;
*sibling_rend = *Lingua::FreeLing3::Bindingsc::TreeIteratorNode_sibling_rend;
*begin = *Lingua::FreeLing3::Bindingsc::TreeIteratorNode_begin;
*end = *Lingua::FreeLing3::Bindingsc::TreeIteratorNode_end;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Lingua::FreeLing3::Bindings::GenericIteratorNode ##############

package Lingua::FreeLing3::Bindings::GenericIteratorNode;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Lingua::FreeLing3::Bindings::TreeIteratorNode Lingua::FreeLing3::Bindings );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Lingua::FreeLing3::Bindingsc::new_GenericIteratorNode(@_);
    bless $self, $pkg if defined($self);
}

*__ref__ = *Lingua::FreeLing3::Bindingsc::GenericIteratorNode___ref__;
*__deref__ = *Lingua::FreeLing3::Bindingsc::GenericIteratorNode___deref__;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Lingua::FreeLing3::Bindingsc::delete_GenericIteratorNode($self);
        delete $OWNER{$self};
    }
}

*swig_info_get = *Lingua::FreeLing3::Bindingsc::GenericIteratorNode_info_get;
*swig_info_set = *Lingua::FreeLing3::Bindingsc::GenericIteratorNode_info_set;
*operator_assignment = *Lingua::FreeLing3::Bindingsc::GenericIteratorNode_operator_assignment;
*num_children = *Lingua::FreeLing3::Bindingsc::GenericIteratorNode_num_children;
*nth_child = *Lingua::FreeLing3::Bindingsc::GenericIteratorNode_nth_child;
*get_parent = *Lingua::FreeLing3::Bindingsc::GenericIteratorNode_get_parent;
*nth_child_ref = *Lingua::FreeLing3::Bindingsc::GenericIteratorNode_nth_child_ref;
*get_info = *Lingua::FreeLing3::Bindingsc::GenericIteratorNode_get_info;
*append_child = *Lingua::FreeLing3::Bindingsc::GenericIteratorNode_append_child;
*hang_child = *Lingua::FreeLing3::Bindingsc::GenericIteratorNode_hang_child;
*clear = *Lingua::FreeLing3::Bindingsc::GenericIteratorNode_clear;
*empty = *Lingua::FreeLing3::Bindingsc::GenericIteratorNode_empty;
*sibling_begin = *Lingua::FreeLing3::Bindingsc::GenericIteratorNode_sibling_begin;
*sibling_end = *Lingua::FreeLing3::Bindingsc::GenericIteratorNode_sibling_end;
*sibling_rbegin = *Lingua::FreeLing3::Bindingsc::GenericIteratorNode_sibling_rbegin;
*sibling_rend = *Lingua::FreeLing3::Bindingsc::GenericIteratorNode_sibling_rend;
*begin = *Lingua::FreeLing3::Bindingsc::GenericIteratorNode_begin;
*end = *Lingua::FreeLing3::Bindingsc::GenericIteratorNode_end;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Lingua::FreeLing3::Bindings::PreorderIteratorNode ##############

package Lingua::FreeLing3::Bindings::PreorderIteratorNode;
use overload
    "--" => sub { $_[0]->__minmin__()},
    "++" => sub { $_[0]->__plusplus__()},
    "=" => sub { my $class = ref($_[0]); $class->new($_[0]) },
    "fallback" => 1;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Lingua::FreeLing3::Bindings::GenericIteratorNode Lingua::FreeLing3::Bindings );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Lingua::FreeLing3::Bindingsc::new_PreorderIteratorNode(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Lingua::FreeLing3::Bindingsc::delete_PreorderIteratorNode($self);
        delete $OWNER{$self};
    }
}

*__plusplus__ = *Lingua::FreeLing3::Bindingsc::PreorderIteratorNode___plusplus__;
*__minmin__ = *Lingua::FreeLing3::Bindingsc::PreorderIteratorNode___minmin__;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Lingua::FreeLing3::Bindings::SiblingIteratorNode ##############

package Lingua::FreeLing3::Bindings::SiblingIteratorNode;
use overload
    "--" => sub { $_[0]->__minmin__()},
    "++" => sub { $_[0]->__plusplus__()},
    "=" => sub { my $class = ref($_[0]); $class->new($_[0]) },
    "fallback" => 1;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Lingua::FreeLing3::Bindings::GenericIteratorNode Lingua::FreeLing3::Bindings );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Lingua::FreeLing3::Bindingsc::new_SiblingIteratorNode(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Lingua::FreeLing3::Bindingsc::delete_SiblingIteratorNode($self);
        delete $OWNER{$self};
    }
}

*__plusplus__ = *Lingua::FreeLing3::Bindingsc::SiblingIteratorNode___plusplus__;
*__minmin__ = *Lingua::FreeLing3::Bindingsc::SiblingIteratorNode___minmin__;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Lingua::FreeLing3::Bindings::TreeIteratorDepnode ##############

package Lingua::FreeLing3::Bindings::TreeIteratorDepnode;
use overload
    "!=" => sub { $_[0]->__ne__($_[1])},
    "==" => sub { $_[0]->__eq__($_[1])},
    "=" => sub { my $class = ref($_[0]); $class->new($_[0]) },
    "fallback" => 1;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Lingua::FreeLing3::Bindings );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Lingua::FreeLing3::Bindingsc::new_TreeIteratorDepnode(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Lingua::FreeLing3::Bindingsc::delete_TreeIteratorDepnode($self);
        delete $OWNER{$self};
    }
}

*__ref__ = *Lingua::FreeLing3::Bindingsc::TreeIteratorDepnode___ref__;
*__deref__ = *Lingua::FreeLing3::Bindingsc::TreeIteratorDepnode___deref__;
*__eq__ = *Lingua::FreeLing3::Bindingsc::TreeIteratorDepnode___eq__;
*__ne__ = *Lingua::FreeLing3::Bindingsc::TreeIteratorDepnode___ne__;
*swig_info_get = *Lingua::FreeLing3::Bindingsc::TreeIteratorDepnode_info_get;
*swig_info_set = *Lingua::FreeLing3::Bindingsc::TreeIteratorDepnode_info_set;
*num_children = *Lingua::FreeLing3::Bindingsc::TreeIteratorDepnode_num_children;
*nth_child = *Lingua::FreeLing3::Bindingsc::TreeIteratorDepnode_nth_child;
*get_parent = *Lingua::FreeLing3::Bindingsc::TreeIteratorDepnode_get_parent;
*nth_child_ref = *Lingua::FreeLing3::Bindingsc::TreeIteratorDepnode_nth_child_ref;
*empty = *Lingua::FreeLing3::Bindingsc::TreeIteratorDepnode_empty;
*sibling_begin = *Lingua::FreeLing3::Bindingsc::TreeIteratorDepnode_sibling_begin;
*sibling_end = *Lingua::FreeLing3::Bindingsc::TreeIteratorDepnode_sibling_end;
*sibling_rbegin = *Lingua::FreeLing3::Bindingsc::TreeIteratorDepnode_sibling_rbegin;
*sibling_rend = *Lingua::FreeLing3::Bindingsc::TreeIteratorDepnode_sibling_rend;
*begin = *Lingua::FreeLing3::Bindingsc::TreeIteratorDepnode_begin;
*end = *Lingua::FreeLing3::Bindingsc::TreeIteratorDepnode_end;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Lingua::FreeLing3::Bindings::GenericIteratorDepnode ##############

package Lingua::FreeLing3::Bindings::GenericIteratorDepnode;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Lingua::FreeLing3::Bindings::TreeIteratorDepnode Lingua::FreeLing3::Bindings );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Lingua::FreeLing3::Bindingsc::new_GenericIteratorDepnode(@_);
    bless $self, $pkg if defined($self);
}

*__ref__ = *Lingua::FreeLing3::Bindingsc::GenericIteratorDepnode___ref__;
*__deref__ = *Lingua::FreeLing3::Bindingsc::GenericIteratorDepnode___deref__;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Lingua::FreeLing3::Bindingsc::delete_GenericIteratorDepnode($self);
        delete $OWNER{$self};
    }
}

*swig_info_get = *Lingua::FreeLing3::Bindingsc::GenericIteratorDepnode_info_get;
*swig_info_set = *Lingua::FreeLing3::Bindingsc::GenericIteratorDepnode_info_set;
*operator_assignment = *Lingua::FreeLing3::Bindingsc::GenericIteratorDepnode_operator_assignment;
*num_children = *Lingua::FreeLing3::Bindingsc::GenericIteratorDepnode_num_children;
*nth_child = *Lingua::FreeLing3::Bindingsc::GenericIteratorDepnode_nth_child;
*get_parent = *Lingua::FreeLing3::Bindingsc::GenericIteratorDepnode_get_parent;
*nth_child_ref = *Lingua::FreeLing3::Bindingsc::GenericIteratorDepnode_nth_child_ref;
*get_info = *Lingua::FreeLing3::Bindingsc::GenericIteratorDepnode_get_info;
*append_child = *Lingua::FreeLing3::Bindingsc::GenericIteratorDepnode_append_child;
*hang_child = *Lingua::FreeLing3::Bindingsc::GenericIteratorDepnode_hang_child;
*clear = *Lingua::FreeLing3::Bindingsc::GenericIteratorDepnode_clear;
*empty = *Lingua::FreeLing3::Bindingsc::GenericIteratorDepnode_empty;
*sibling_begin = *Lingua::FreeLing3::Bindingsc::GenericIteratorDepnode_sibling_begin;
*sibling_end = *Lingua::FreeLing3::Bindingsc::GenericIteratorDepnode_sibling_end;
*sibling_rbegin = *Lingua::FreeLing3::Bindingsc::GenericIteratorDepnode_sibling_rbegin;
*sibling_rend = *Lingua::FreeLing3::Bindingsc::GenericIteratorDepnode_sibling_rend;
*begin = *Lingua::FreeLing3::Bindingsc::GenericIteratorDepnode_begin;
*end = *Lingua::FreeLing3::Bindingsc::GenericIteratorDepnode_end;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Lingua::FreeLing3::Bindings::PreorderIteratorDepnode ##############

package Lingua::FreeLing3::Bindings::PreorderIteratorDepnode;
use overload
    "--" => sub { $_[0]->__minmin__()},
    "++" => sub { $_[0]->__plusplus__()},
    "=" => sub { my $class = ref($_[0]); $class->new($_[0]) },
    "fallback" => 1;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Lingua::FreeLing3::Bindings::GenericIteratorDepnode Lingua::FreeLing3::Bindings );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Lingua::FreeLing3::Bindingsc::new_PreorderIteratorDepnode(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Lingua::FreeLing3::Bindingsc::delete_PreorderIteratorDepnode($self);
        delete $OWNER{$self};
    }
}

*__plusplus__ = *Lingua::FreeLing3::Bindingsc::PreorderIteratorDepnode___plusplus__;
*__minmin__ = *Lingua::FreeLing3::Bindingsc::PreorderIteratorDepnode___minmin__;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Lingua::FreeLing3::Bindings::SiblingIteratorDepnode ##############

package Lingua::FreeLing3::Bindings::SiblingIteratorDepnode;
use overload
    "--" => sub { $_[0]->__minmin__()},
    "++" => sub { $_[0]->__plusplus__()},
    "=" => sub { my $class = ref($_[0]); $class->new($_[0]) },
    "fallback" => 1;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Lingua::FreeLing3::Bindings::GenericIteratorDepnode Lingua::FreeLing3::Bindings );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Lingua::FreeLing3::Bindingsc::new_SiblingIteratorDepnode(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Lingua::FreeLing3::Bindingsc::delete_SiblingIteratorDepnode($self);
        delete $OWNER{$self};
    }
}

*__plusplus__ = *Lingua::FreeLing3::Bindingsc::SiblingIteratorDepnode___plusplus__;
*__minmin__ = *Lingua::FreeLing3::Bindingsc::SiblingIteratorDepnode___minmin__;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Lingua::FreeLing3::Bindings::TreeIteratorNodeConst ##############

package Lingua::FreeLing3::Bindings::TreeIteratorNodeConst;
use overload
    "!=" => sub { $_[0]->__ne__($_[1])},
    "==" => sub { $_[0]->__eq__($_[1])},
    "=" => sub { my $class = ref($_[0]); $class->new($_[0]) },
    "fallback" => 1;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Lingua::FreeLing3::Bindings );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Lingua::FreeLing3::Bindingsc::new_TreeIteratorNodeConst(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Lingua::FreeLing3::Bindingsc::delete_TreeIteratorNodeConst($self);
        delete $OWNER{$self};
    }
}

*__ref__ = *Lingua::FreeLing3::Bindingsc::TreeIteratorNodeConst___ref__;
*__deref__ = *Lingua::FreeLing3::Bindingsc::TreeIteratorNodeConst___deref__;
*__eq__ = *Lingua::FreeLing3::Bindingsc::TreeIteratorNodeConst___eq__;
*__ne__ = *Lingua::FreeLing3::Bindingsc::TreeIteratorNodeConst___ne__;
*swig_info_get = *Lingua::FreeLing3::Bindingsc::TreeIteratorNodeConst_info_get;
*swig_info_set = *Lingua::FreeLing3::Bindingsc::TreeIteratorNodeConst_info_set;
*num_children = *Lingua::FreeLing3::Bindingsc::TreeIteratorNodeConst_num_children;
*nth_child = *Lingua::FreeLing3::Bindingsc::TreeIteratorNodeConst_nth_child;
*get_parent = *Lingua::FreeLing3::Bindingsc::TreeIteratorNodeConst_get_parent;
*nth_child_ref = *Lingua::FreeLing3::Bindingsc::TreeIteratorNodeConst_nth_child_ref;
*empty = *Lingua::FreeLing3::Bindingsc::TreeIteratorNodeConst_empty;
*sibling_begin = *Lingua::FreeLing3::Bindingsc::TreeIteratorNodeConst_sibling_begin;
*sibling_end = *Lingua::FreeLing3::Bindingsc::TreeIteratorNodeConst_sibling_end;
*sibling_rbegin = *Lingua::FreeLing3::Bindingsc::TreeIteratorNodeConst_sibling_rbegin;
*sibling_rend = *Lingua::FreeLing3::Bindingsc::TreeIteratorNodeConst_sibling_rend;
*begin = *Lingua::FreeLing3::Bindingsc::TreeIteratorNodeConst_begin;
*end = *Lingua::FreeLing3::Bindingsc::TreeIteratorNodeConst_end;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Lingua::FreeLing3::Bindings::GenericConstIteratorNode ##############

package Lingua::FreeLing3::Bindings::GenericConstIteratorNode;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Lingua::FreeLing3::Bindings::TreeIteratorNodeConst Lingua::FreeLing3::Bindings );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Lingua::FreeLing3::Bindingsc::new_GenericConstIteratorNode(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Lingua::FreeLing3::Bindingsc::delete_GenericConstIteratorNode($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Lingua::FreeLing3::Bindings::ConstPreorderIteratorNode ##############

package Lingua::FreeLing3::Bindings::ConstPreorderIteratorNode;
use overload
    "--" => sub { $_[0]->__minmin__()},
    "++" => sub { $_[0]->__plusplus__()},
    "=" => sub { my $class = ref($_[0]); $class->new($_[0]) },
    "fallback" => 1;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Lingua::FreeLing3::Bindings::GenericConstIteratorNode Lingua::FreeLing3::Bindings );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Lingua::FreeLing3::Bindingsc::new_ConstPreorderIteratorNode(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Lingua::FreeLing3::Bindingsc::delete_ConstPreorderIteratorNode($self);
        delete $OWNER{$self};
    }
}

*__plusplus__ = *Lingua::FreeLing3::Bindingsc::ConstPreorderIteratorNode___plusplus__;
*__minmin__ = *Lingua::FreeLing3::Bindingsc::ConstPreorderIteratorNode___minmin__;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Lingua::FreeLing3::Bindings::ConstSiblingIteratorNode ##############

package Lingua::FreeLing3::Bindings::ConstSiblingIteratorNode;
use overload
    "--" => sub { $_[0]->__minmin__()},
    "++" => sub { $_[0]->__plusplus__()},
    "=" => sub { my $class = ref($_[0]); $class->new($_[0]) },
    "fallback" => 1;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Lingua::FreeLing3::Bindings::GenericConstIteratorNode Lingua::FreeLing3::Bindings );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Lingua::FreeLing3::Bindingsc::new_ConstSiblingIteratorNode(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Lingua::FreeLing3::Bindingsc::delete_ConstSiblingIteratorNode($self);
        delete $OWNER{$self};
    }
}

*__plusplus__ = *Lingua::FreeLing3::Bindingsc::ConstSiblingIteratorNode___plusplus__;
*__minmin__ = *Lingua::FreeLing3::Bindingsc::ConstSiblingIteratorNode___minmin__;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Lingua::FreeLing3::Bindings::TreeIteratorDepnodeConst ##############

package Lingua::FreeLing3::Bindings::TreeIteratorDepnodeConst;
use overload
    "!=" => sub { $_[0]->__ne__($_[1])},
    "==" => sub { $_[0]->__eq__($_[1])},
    "=" => sub { my $class = ref($_[0]); $class->new($_[0]) },
    "fallback" => 1;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Lingua::FreeLing3::Bindings );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Lingua::FreeLing3::Bindingsc::new_TreeIteratorDepnodeConst(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Lingua::FreeLing3::Bindingsc::delete_TreeIteratorDepnodeConst($self);
        delete $OWNER{$self};
    }
}

*__ref__ = *Lingua::FreeLing3::Bindingsc::TreeIteratorDepnodeConst___ref__;
*__deref__ = *Lingua::FreeLing3::Bindingsc::TreeIteratorDepnodeConst___deref__;
*__eq__ = *Lingua::FreeLing3::Bindingsc::TreeIteratorDepnodeConst___eq__;
*__ne__ = *Lingua::FreeLing3::Bindingsc::TreeIteratorDepnodeConst___ne__;
*swig_info_get = *Lingua::FreeLing3::Bindingsc::TreeIteratorDepnodeConst_info_get;
*swig_info_set = *Lingua::FreeLing3::Bindingsc::TreeIteratorDepnodeConst_info_set;
*num_children = *Lingua::FreeLing3::Bindingsc::TreeIteratorDepnodeConst_num_children;
*nth_child = *Lingua::FreeLing3::Bindingsc::TreeIteratorDepnodeConst_nth_child;
*get_parent = *Lingua::FreeLing3::Bindingsc::TreeIteratorDepnodeConst_get_parent;
*nth_child_ref = *Lingua::FreeLing3::Bindingsc::TreeIteratorDepnodeConst_nth_child_ref;
*empty = *Lingua::FreeLing3::Bindingsc::TreeIteratorDepnodeConst_empty;
*sibling_begin = *Lingua::FreeLing3::Bindingsc::TreeIteratorDepnodeConst_sibling_begin;
*sibling_end = *Lingua::FreeLing3::Bindingsc::TreeIteratorDepnodeConst_sibling_end;
*sibling_rbegin = *Lingua::FreeLing3::Bindingsc::TreeIteratorDepnodeConst_sibling_rbegin;
*sibling_rend = *Lingua::FreeLing3::Bindingsc::TreeIteratorDepnodeConst_sibling_rend;
*begin = *Lingua::FreeLing3::Bindingsc::TreeIteratorDepnodeConst_begin;
*end = *Lingua::FreeLing3::Bindingsc::TreeIteratorDepnodeConst_end;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Lingua::FreeLing3::Bindings::GenericConstIteratorDepnode ##############

package Lingua::FreeLing3::Bindings::GenericConstIteratorDepnode;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Lingua::FreeLing3::Bindings::TreeIteratorDepnodeConst Lingua::FreeLing3::Bindings );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Lingua::FreeLing3::Bindingsc::new_GenericConstIteratorDepnode(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Lingua::FreeLing3::Bindingsc::delete_GenericConstIteratorDepnode($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Lingua::FreeLing3::Bindings::ConstPreorderIteratorDepnode ##############

package Lingua::FreeLing3::Bindings::ConstPreorderIteratorDepnode;
use overload
    "--" => sub { $_[0]->__minmin__()},
    "++" => sub { $_[0]->__plusplus__()},
    "=" => sub { my $class = ref($_[0]); $class->new($_[0]) },
    "fallback" => 1;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Lingua::FreeLing3::Bindings::GenericConstIteratorDepnode Lingua::FreeLing3::Bindings );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Lingua::FreeLing3::Bindingsc::new_ConstPreorderIteratorDepnode(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Lingua::FreeLing3::Bindingsc::delete_ConstPreorderIteratorDepnode($self);
        delete $OWNER{$self};
    }
}

*__plusplus__ = *Lingua::FreeLing3::Bindingsc::ConstPreorderIteratorDepnode___plusplus__;
*__minmin__ = *Lingua::FreeLing3::Bindingsc::ConstPreorderIteratorDepnode___minmin__;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Lingua::FreeLing3::Bindings::ConstSiblingIteratorDepnode ##############

package Lingua::FreeLing3::Bindings::ConstSiblingIteratorDepnode;
use overload
    "--" => sub { $_[0]->__minmin__()},
    "++" => sub { $_[0]->__plusplus__()},
    "=" => sub { my $class = ref($_[0]); $class->new($_[0]) },
    "fallback" => 1;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Lingua::FreeLing3::Bindings::GenericConstIteratorDepnode Lingua::FreeLing3::Bindings );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Lingua::FreeLing3::Bindingsc::new_ConstSiblingIteratorDepnode(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Lingua::FreeLing3::Bindingsc::delete_ConstSiblingIteratorDepnode($self);
        delete $OWNER{$self};
    }
}

*__plusplus__ = *Lingua::FreeLing3::Bindingsc::ConstSiblingIteratorDepnode___plusplus__;
*__minmin__ = *Lingua::FreeLing3::Bindingsc::ConstSiblingIteratorDepnode___minmin__;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Lingua::FreeLing3::Bindings::TreeNode ##############

package Lingua::FreeLing3::Bindings::TreeNode;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Lingua::FreeLing3::Bindings );
%OWNER = ();
%ITERATORS = ();
*swig_info_get = *Lingua::FreeLing3::Bindingsc::TreeNode_info_get;
*swig_info_set = *Lingua::FreeLing3::Bindingsc::TreeNode_info_set;
sub new {
    my $pkg = shift;
    my $self = Lingua::FreeLing3::Bindingsc::new_TreeNode(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Lingua::FreeLing3::Bindingsc::delete_TreeNode($self);
        delete $OWNER{$self};
    }
}

*operator_assignment = *Lingua::FreeLing3::Bindingsc::TreeNode_operator_assignment;
*num_children = *Lingua::FreeLing3::Bindingsc::TreeNode_num_children;
*nth_child = *Lingua::FreeLing3::Bindingsc::TreeNode_nth_child;
*get_parent = *Lingua::FreeLing3::Bindingsc::TreeNode_get_parent;
*nth_child_ref = *Lingua::FreeLing3::Bindingsc::TreeNode_nth_child_ref;
*get_info = *Lingua::FreeLing3::Bindingsc::TreeNode_get_info;
*append_child = *Lingua::FreeLing3::Bindingsc::TreeNode_append_child;
*hang_child = *Lingua::FreeLing3::Bindingsc::TreeNode_hang_child;
*clear = *Lingua::FreeLing3::Bindingsc::TreeNode_clear;
*empty = *Lingua::FreeLing3::Bindingsc::TreeNode_empty;
*sibling_begin = *Lingua::FreeLing3::Bindingsc::TreeNode_sibling_begin;
*sibling_end = *Lingua::FreeLing3::Bindingsc::TreeNode_sibling_end;
*sibling_rbegin = *Lingua::FreeLing3::Bindingsc::TreeNode_sibling_rbegin;
*sibling_rend = *Lingua::FreeLing3::Bindingsc::TreeNode_sibling_rend;
*begin = *Lingua::FreeLing3::Bindingsc::TreeNode_begin;
*end = *Lingua::FreeLing3::Bindingsc::TreeNode_end;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Lingua::FreeLing3::Bindings::TreeDepnode ##############

package Lingua::FreeLing3::Bindings::TreeDepnode;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Lingua::FreeLing3::Bindings );
%OWNER = ();
%ITERATORS = ();
*swig_info_get = *Lingua::FreeLing3::Bindingsc::TreeDepnode_info_get;
*swig_info_set = *Lingua::FreeLing3::Bindingsc::TreeDepnode_info_set;
sub new {
    my $pkg = shift;
    my $self = Lingua::FreeLing3::Bindingsc::new_TreeDepnode(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Lingua::FreeLing3::Bindingsc::delete_TreeDepnode($self);
        delete $OWNER{$self};
    }
}

*operator_assignment = *Lingua::FreeLing3::Bindingsc::TreeDepnode_operator_assignment;
*num_children = *Lingua::FreeLing3::Bindingsc::TreeDepnode_num_children;
*nth_child = *Lingua::FreeLing3::Bindingsc::TreeDepnode_nth_child;
*get_parent = *Lingua::FreeLing3::Bindingsc::TreeDepnode_get_parent;
*nth_child_ref = *Lingua::FreeLing3::Bindingsc::TreeDepnode_nth_child_ref;
*get_info = *Lingua::FreeLing3::Bindingsc::TreeDepnode_get_info;
*append_child = *Lingua::FreeLing3::Bindingsc::TreeDepnode_append_child;
*hang_child = *Lingua::FreeLing3::Bindingsc::TreeDepnode_hang_child;
*clear = *Lingua::FreeLing3::Bindingsc::TreeDepnode_clear;
*empty = *Lingua::FreeLing3::Bindingsc::TreeDepnode_empty;
*sibling_begin = *Lingua::FreeLing3::Bindingsc::TreeDepnode_sibling_begin;
*sibling_end = *Lingua::FreeLing3::Bindingsc::TreeDepnode_sibling_end;
*sibling_rbegin = *Lingua::FreeLing3::Bindingsc::TreeDepnode_sibling_rbegin;
*sibling_rend = *Lingua::FreeLing3::Bindingsc::TreeDepnode_sibling_rend;
*begin = *Lingua::FreeLing3::Bindingsc::TreeDepnode_begin;
*end = *Lingua::FreeLing3::Bindingsc::TreeDepnode_end;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Lingua::FreeLing3::Bindings::analysis ##############

package Lingua::FreeLing3::Bindings::analysis;
use overload
    "<" => sub { $_[0]->__lt__($_[1])},
    "==" => sub { $_[0]->__eq__($_[1])},
    ">" => sub { $_[0]->__gt__($_[1])},
    "=" => sub { my $class = ref($_[0]); $class->new($_[0]) },
    "fallback" => 1;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Lingua::FreeLing3::Bindings );
%OWNER = ();
%ITERATORS = ();
*swig_user_get = *Lingua::FreeLing3::Bindingsc::analysis_user_get;
*swig_user_set = *Lingua::FreeLing3::Bindingsc::analysis_user_set;
sub new {
    my $pkg = shift;
    my $self = Lingua::FreeLing3::Bindingsc::new_analysis(@_);
    bless $self, $pkg if defined($self);
}

*operator_assignment = *Lingua::FreeLing3::Bindingsc::analysis_operator_assignment;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Lingua::FreeLing3::Bindingsc::delete_analysis($self);
        delete $OWNER{$self};
    }
}

*init = *Lingua::FreeLing3::Bindingsc::analysis_init;
*set_lemma = *Lingua::FreeLing3::Bindingsc::analysis_set_lemma;
*set_tag = *Lingua::FreeLing3::Bindingsc::analysis_set_tag;
*set_prob = *Lingua::FreeLing3::Bindingsc::analysis_set_prob;
*set_distance = *Lingua::FreeLing3::Bindingsc::analysis_set_distance;
*set_retokenizable = *Lingua::FreeLing3::Bindingsc::analysis_set_retokenizable;
*has_prob = *Lingua::FreeLing3::Bindingsc::analysis_has_prob;
*has_distance = *Lingua::FreeLing3::Bindingsc::analysis_has_distance;
*get_lemma = *Lingua::FreeLing3::Bindingsc::analysis_get_lemma;
*get_tag = *Lingua::FreeLing3::Bindingsc::analysis_get_tag;
*get_prob = *Lingua::FreeLing3::Bindingsc::analysis_get_prob;
*get_distance = *Lingua::FreeLing3::Bindingsc::analysis_get_distance;
*is_retokenizable = *Lingua::FreeLing3::Bindingsc::analysis_is_retokenizable;
*get_retokenizable = *Lingua::FreeLing3::Bindingsc::analysis_get_retokenizable;
*get_senses = *Lingua::FreeLing3::Bindingsc::analysis_get_senses;
*set_senses = *Lingua::FreeLing3::Bindingsc::analysis_set_senses;
*get_senses_string = *Lingua::FreeLing3::Bindingsc::analysis_get_senses_string;
*__gt__ = *Lingua::FreeLing3::Bindingsc::analysis___gt__;
*__lt__ = *Lingua::FreeLing3::Bindingsc::analysis___lt__;
*__eq__ = *Lingua::FreeLing3::Bindingsc::analysis___eq__;
*is_selected = *Lingua::FreeLing3::Bindingsc::analysis_is_selected;
*mark_selected = *Lingua::FreeLing3::Bindingsc::analysis_mark_selected;
*unmark_selected = *Lingua::FreeLing3::Bindingsc::analysis_unmark_selected;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Lingua::FreeLing3::Bindings::word ##############

package Lingua::FreeLing3::Bindings::word;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Lingua::FreeLing3::Bindings::ListAnalysis Lingua::FreeLing3::Bindings );
%OWNER = ();
%ITERATORS = ();
*swig_user_get = *Lingua::FreeLing3::Bindingsc::word_user_get;
*swig_user_set = *Lingua::FreeLing3::Bindingsc::word_user_set;
sub new {
    my $pkg = shift;
    my $self = Lingua::FreeLing3::Bindingsc::new_word(@_);
    bless $self, $pkg if defined($self);
}

*operator_assignment = *Lingua::FreeLing3::Bindingsc::word_operator_assignment;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Lingua::FreeLing3::Bindingsc::delete_word($self);
        delete $OWNER{$self};
    }
}

*copy_analysis = *Lingua::FreeLing3::Bindingsc::word_copy_analysis;
*get_n_selected = *Lingua::FreeLing3::Bindingsc::word_get_n_selected;
*get_n_unselected = *Lingua::FreeLing3::Bindingsc::word_get_n_unselected;
*is_multiword = *Lingua::FreeLing3::Bindingsc::word_is_multiword;
*is_ambiguous_mw = *Lingua::FreeLing3::Bindingsc::word_is_ambiguous_mw;
*set_ambiguous_mw = *Lingua::FreeLing3::Bindingsc::word_set_ambiguous_mw;
*get_n_words_mw = *Lingua::FreeLing3::Bindingsc::word_get_n_words_mw;
*get_words_mw = *Lingua::FreeLing3::Bindingsc::word_get_words_mw;
*get_form = *Lingua::FreeLing3::Bindingsc::word_get_form;
*get_lc_form = *Lingua::FreeLing3::Bindingsc::word_get_lc_form;
*get_ph_form = *Lingua::FreeLing3::Bindingsc::word_get_ph_form;
*selected_begin = *Lingua::FreeLing3::Bindingsc::word_selected_begin;
*selected_end = *Lingua::FreeLing3::Bindingsc::word_selected_end;
*unselected_begin = *Lingua::FreeLing3::Bindingsc::word_unselected_begin;
*unselected_end = *Lingua::FreeLing3::Bindingsc::word_unselected_end;
*num_kbest = *Lingua::FreeLing3::Bindingsc::word_num_kbest;
*get_lemma = *Lingua::FreeLing3::Bindingsc::word_get_lemma;
*get_tag = *Lingua::FreeLing3::Bindingsc::word_get_tag;
*get_senses = *Lingua::FreeLing3::Bindingsc::word_get_senses;
*get_senses_string = *Lingua::FreeLing3::Bindingsc::word_get_senses_string;
*set_senses = *Lingua::FreeLing3::Bindingsc::word_set_senses;
*get_span_start = *Lingua::FreeLing3::Bindingsc::word_get_span_start;
*get_span_finish = *Lingua::FreeLing3::Bindingsc::word_get_span_finish;
*found_in_dict = *Lingua::FreeLing3::Bindingsc::word_found_in_dict;
*set_found_in_dict = *Lingua::FreeLing3::Bindingsc::word_set_found_in_dict;
*has_retokenizable = *Lingua::FreeLing3::Bindingsc::word_has_retokenizable;
*lock_analysis = *Lingua::FreeLing3::Bindingsc::word_lock_analysis;
*is_locked = *Lingua::FreeLing3::Bindingsc::word_is_locked;
*add_alternative = *Lingua::FreeLing3::Bindingsc::word_add_alternative;
*set_alternatives = *Lingua::FreeLing3::Bindingsc::word_set_alternatives;
*clear_alternatives = *Lingua::FreeLing3::Bindingsc::word_clear_alternatives;
*has_alternatives = *Lingua::FreeLing3::Bindingsc::word_has_alternatives;
*get_alternatives = *Lingua::FreeLing3::Bindingsc::word_get_alternatives;
*alternatives_begin = *Lingua::FreeLing3::Bindingsc::word_alternatives_begin;
*alternatives_end = *Lingua::FreeLing3::Bindingsc::word_alternatives_end;
*add_analysis = *Lingua::FreeLing3::Bindingsc::word_add_analysis;
*set_analysis = *Lingua::FreeLing3::Bindingsc::word_set_analysis;
*set_form = *Lingua::FreeLing3::Bindingsc::word_set_form;
*set_ph_form = *Lingua::FreeLing3::Bindingsc::word_set_ph_form;
*set_span = *Lingua::FreeLing3::Bindingsc::word_set_span;
*set_position = *Lingua::FreeLing3::Bindingsc::word_set_position;
*get_position = *Lingua::FreeLing3::Bindingsc::word_get_position;
*find_tag_match = *Lingua::FreeLing3::Bindingsc::word_find_tag_match;
*get_n_analysis = *Lingua::FreeLing3::Bindingsc::word_get_n_analysis;
*unselect_all_analysis = *Lingua::FreeLing3::Bindingsc::word_unselect_all_analysis;
*select_all_analysis = *Lingua::FreeLing3::Bindingsc::word_select_all_analysis;
*select_analysis = *Lingua::FreeLing3::Bindingsc::word_select_analysis;
*unselect_analysis = *Lingua::FreeLing3::Bindingsc::word_unselect_analysis;
*get_analysis = *Lingua::FreeLing3::Bindingsc::word_get_analysis;
*analysis_begin = *Lingua::FreeLing3::Bindingsc::word_analysis_begin;
*analysis_end = *Lingua::FreeLing3::Bindingsc::word_analysis_end;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Lingua::FreeLing3::Bindings::node ##############

package Lingua::FreeLing3::Bindings::node;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Lingua::FreeLing3::Bindings );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Lingua::FreeLing3::Bindingsc::new_node(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Lingua::FreeLing3::Bindingsc::delete_node($self);
        delete $OWNER{$self};
    }
}

*get_node_id = *Lingua::FreeLing3::Bindingsc::node_get_node_id;
*set_node_id = *Lingua::FreeLing3::Bindingsc::node_set_node_id;
*get_label = *Lingua::FreeLing3::Bindingsc::node_get_label;
*get_word = *Lingua::FreeLing3::Bindingsc::node_get_word;
*set_label = *Lingua::FreeLing3::Bindingsc::node_set_label;
*set_word = *Lingua::FreeLing3::Bindingsc::node_set_word;
*is_head = *Lingua::FreeLing3::Bindingsc::node_is_head;
*set_head = *Lingua::FreeLing3::Bindingsc::node_set_head;
*is_chunk = *Lingua::FreeLing3::Bindingsc::node_is_chunk;
*set_chunk = *Lingua::FreeLing3::Bindingsc::node_set_chunk;
*get_chunk_ord = *Lingua::FreeLing3::Bindingsc::node_get_chunk_ord;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Lingua::FreeLing3::Bindings::parse_tree ##############

package Lingua::FreeLing3::Bindings::parse_tree;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Lingua::FreeLing3::Bindings::TreeNode Lingua::FreeLing3::Bindings );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Lingua::FreeLing3::Bindingsc::new_parse_tree(@_);
    bless $self, $pkg if defined($self);
}

*build_node_index = *Lingua::FreeLing3::Bindingsc::parse_tree_build_node_index;
*rebuild_node_index = *Lingua::FreeLing3::Bindingsc::parse_tree_rebuild_node_index;
*get_node_by_id = *Lingua::FreeLing3::Bindingsc::parse_tree_get_node_by_id;
*get_node_by_pos = *Lingua::FreeLing3::Bindingsc::parse_tree_get_node_by_pos;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Lingua::FreeLing3::Bindingsc::delete_parse_tree($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Lingua::FreeLing3::Bindings::depnode ##############

package Lingua::FreeLing3::Bindings::depnode;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Lingua::FreeLing3::Bindings::node Lingua::FreeLing3::Bindings );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Lingua::FreeLing3::Bindingsc::new_depnode(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Lingua::FreeLing3::Bindingsc::delete_depnode($self);
        delete $OWNER{$self};
    }
}

*set_link = *Lingua::FreeLing3::Bindingsc::depnode_set_link;
*get_link = *Lingua::FreeLing3::Bindingsc::depnode_get_link;
*get_link_ref = *Lingua::FreeLing3::Bindingsc::depnode_get_link_ref;
*set_label = *Lingua::FreeLing3::Bindingsc::depnode_set_label;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Lingua::FreeLing3::Bindings::dep_tree ##############

package Lingua::FreeLing3::Bindings::dep_tree;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Lingua::FreeLing3::Bindings::TreeDepnode Lingua::FreeLing3::Bindings );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Lingua::FreeLing3::Bindingsc::new_dep_tree(@_);
    bless $self, $pkg if defined($self);
}

*get_node_by_pos = *Lingua::FreeLing3::Bindingsc::dep_tree_get_node_by_pos;
*rebuild_node_index = *Lingua::FreeLing3::Bindingsc::dep_tree_rebuild_node_index;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Lingua::FreeLing3::Bindingsc::delete_dep_tree($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Lingua::FreeLing3::Bindings::sentence ##############

package Lingua::FreeLing3::Bindings::sentence;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Lingua::FreeLing3::Bindings::ListWord Lingua::FreeLing3::Bindings );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Lingua::FreeLing3::Bindingsc::new_sentence(@_);
    bless $self, $pkg if defined($self);
}

*operator_assignment = *Lingua::FreeLing3::Bindingsc::sentence_operator_assignment;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Lingua::FreeLing3::Bindingsc::delete_sentence($self);
        delete $OWNER{$self};
    }
}

*num_kbest = *Lingua::FreeLing3::Bindingsc::sentence_num_kbest;
*push_back = *Lingua::FreeLing3::Bindingsc::sentence_push_back;
*rebuild_word_index = *Lingua::FreeLing3::Bindingsc::sentence_rebuild_word_index;
*clear = *Lingua::FreeLing3::Bindingsc::sentence_clear;
*set_sentence_id = *Lingua::FreeLing3::Bindingsc::sentence_set_sentence_id;
*get_sentence_id = *Lingua::FreeLing3::Bindingsc::sentence_get_sentence_id;
*set_parse_tree = *Lingua::FreeLing3::Bindingsc::sentence_set_parse_tree;
*get_parse_tree = *Lingua::FreeLing3::Bindingsc::sentence_get_parse_tree;
*is_parsed = *Lingua::FreeLing3::Bindingsc::sentence_is_parsed;
*set_dep_tree = *Lingua::FreeLing3::Bindingsc::sentence_set_dep_tree;
*get_dep_tree = *Lingua::FreeLing3::Bindingsc::sentence_get_dep_tree;
*is_dep_parsed = *Lingua::FreeLing3::Bindingsc::sentence_is_dep_parsed;
*get_words = *Lingua::FreeLing3::Bindingsc::sentence_get_words;
*words_begin = *Lingua::FreeLing3::Bindingsc::sentence_words_begin;
*words_end = *Lingua::FreeLing3::Bindingsc::sentence_words_end;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Lingua::FreeLing3::Bindings::paragraph ##############

package Lingua::FreeLing3::Bindings::paragraph;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Lingua::FreeLing3::Bindings::ListSentence Lingua::FreeLing3::Bindings );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Lingua::FreeLing3::Bindingsc::new_paragraph(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Lingua::FreeLing3::Bindingsc::delete_paragraph($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Lingua::FreeLing3::Bindings::document ##############

package Lingua::FreeLing3::Bindings::document;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Lingua::FreeLing3::Bindings::ListParagraph Lingua::FreeLing3::Bindings );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Lingua::FreeLing3::Bindingsc::new_document(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Lingua::FreeLing3::Bindingsc::delete_document($self);
        delete $OWNER{$self};
    }
}

*add_positive = *Lingua::FreeLing3::Bindingsc::document_add_positive;
*get_coref_group = *Lingua::FreeLing3::Bindingsc::document_get_coref_group;
*get_coref_nodes = *Lingua::FreeLing3::Bindingsc::document_get_coref_nodes;
*is_coref = *Lingua::FreeLing3::Bindingsc::document_is_coref;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Lingua::FreeLing3::Bindings::traces ##############

package Lingua::FreeLing3::Bindings::traces;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Lingua::FreeLing3::Bindings );
%OWNER = ();
%ITERATORS = ();
*TraceLevel = *Lingua::FreeLing3::Bindingsc::traces_TraceLevel;
*TraceModule = *Lingua::FreeLing3::Bindingsc::traces_TraceModule;
sub new {
    my $pkg = shift;
    my $self = Lingua::FreeLing3::Bindingsc::new_traces(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Lingua::FreeLing3::Bindingsc::delete_traces($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Lingua::FreeLing3::Bindings::lang_ident ##############

package Lingua::FreeLing3::Bindings::lang_ident;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Lingua::FreeLing3::Bindings );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Lingua::FreeLing3::Bindingsc::new_lang_ident(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Lingua::FreeLing3::Bindingsc::delete_lang_ident($self);
        delete $OWNER{$self};
    }
}

*add_language = *Lingua::FreeLing3::Bindingsc::lang_ident_add_language;
*train_language = *Lingua::FreeLing3::Bindingsc::lang_ident_train_language;
*identify_language = *Lingua::FreeLing3::Bindingsc::lang_ident_identify_language;
*rank_languages = *Lingua::FreeLing3::Bindingsc::lang_ident_rank_languages;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Lingua::FreeLing3::Bindings::tokenizer ##############

package Lingua::FreeLing3::Bindings::tokenizer;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Lingua::FreeLing3::Bindings );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Lingua::FreeLing3::Bindingsc::new_tokenizer(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Lingua::FreeLing3::Bindingsc::delete_tokenizer($self);
        delete $OWNER{$self};
    }
}

*tokenize = *Lingua::FreeLing3::Bindingsc::tokenizer_tokenize;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Lingua::FreeLing3::Bindings::splitter ##############

package Lingua::FreeLing3::Bindings::splitter;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Lingua::FreeLing3::Bindings );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Lingua::FreeLing3::Bindingsc::new_splitter(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Lingua::FreeLing3::Bindingsc::delete_splitter($self);
        delete $OWNER{$self};
    }
}

*split = *Lingua::FreeLing3::Bindingsc::splitter_split;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Lingua::FreeLing3::Bindings::maco_options ##############

package Lingua::FreeLing3::Bindings::maco_options;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Lingua::FreeLing3::Bindings );
%OWNER = ();
%ITERATORS = ();
*swig_Lang_get = *Lingua::FreeLing3::Bindingsc::maco_options_Lang_get;
*swig_Lang_set = *Lingua::FreeLing3::Bindingsc::maco_options_Lang_set;
*swig_AffixAnalysis_get = *Lingua::FreeLing3::Bindingsc::maco_options_AffixAnalysis_get;
*swig_AffixAnalysis_set = *Lingua::FreeLing3::Bindingsc::maco_options_AffixAnalysis_set;
*swig_MultiwordsDetection_get = *Lingua::FreeLing3::Bindingsc::maco_options_MultiwordsDetection_get;
*swig_MultiwordsDetection_set = *Lingua::FreeLing3::Bindingsc::maco_options_MultiwordsDetection_set;
*swig_NumbersDetection_get = *Lingua::FreeLing3::Bindingsc::maco_options_NumbersDetection_get;
*swig_NumbersDetection_set = *Lingua::FreeLing3::Bindingsc::maco_options_NumbersDetection_set;
*swig_PunctuationDetection_get = *Lingua::FreeLing3::Bindingsc::maco_options_PunctuationDetection_get;
*swig_PunctuationDetection_set = *Lingua::FreeLing3::Bindingsc::maco_options_PunctuationDetection_set;
*swig_DatesDetection_get = *Lingua::FreeLing3::Bindingsc::maco_options_DatesDetection_get;
*swig_DatesDetection_set = *Lingua::FreeLing3::Bindingsc::maco_options_DatesDetection_set;
*swig_QuantitiesDetection_get = *Lingua::FreeLing3::Bindingsc::maco_options_QuantitiesDetection_get;
*swig_QuantitiesDetection_set = *Lingua::FreeLing3::Bindingsc::maco_options_QuantitiesDetection_set;
*swig_DictionarySearch_get = *Lingua::FreeLing3::Bindingsc::maco_options_DictionarySearch_get;
*swig_DictionarySearch_set = *Lingua::FreeLing3::Bindingsc::maco_options_DictionarySearch_set;
*swig_ProbabilityAssignment_get = *Lingua::FreeLing3::Bindingsc::maco_options_ProbabilityAssignment_get;
*swig_ProbabilityAssignment_set = *Lingua::FreeLing3::Bindingsc::maco_options_ProbabilityAssignment_set;
*swig_UserMap_get = *Lingua::FreeLing3::Bindingsc::maco_options_UserMap_get;
*swig_UserMap_set = *Lingua::FreeLing3::Bindingsc::maco_options_UserMap_set;
*swig_NERecognition_get = *Lingua::FreeLing3::Bindingsc::maco_options_NERecognition_get;
*swig_NERecognition_set = *Lingua::FreeLing3::Bindingsc::maco_options_NERecognition_set;
*swig_LocutionsFile_get = *Lingua::FreeLing3::Bindingsc::maco_options_LocutionsFile_get;
*swig_LocutionsFile_set = *Lingua::FreeLing3::Bindingsc::maco_options_LocutionsFile_set;
*swig_QuantitiesFile_get = *Lingua::FreeLing3::Bindingsc::maco_options_QuantitiesFile_get;
*swig_QuantitiesFile_set = *Lingua::FreeLing3::Bindingsc::maco_options_QuantitiesFile_set;
*swig_AffixFile_get = *Lingua::FreeLing3::Bindingsc::maco_options_AffixFile_get;
*swig_AffixFile_set = *Lingua::FreeLing3::Bindingsc::maco_options_AffixFile_set;
*swig_ProbabilityFile_get = *Lingua::FreeLing3::Bindingsc::maco_options_ProbabilityFile_get;
*swig_ProbabilityFile_set = *Lingua::FreeLing3::Bindingsc::maco_options_ProbabilityFile_set;
*swig_DictionaryFile_get = *Lingua::FreeLing3::Bindingsc::maco_options_DictionaryFile_get;
*swig_DictionaryFile_set = *Lingua::FreeLing3::Bindingsc::maco_options_DictionaryFile_set;
*swig_NPdataFile_get = *Lingua::FreeLing3::Bindingsc::maco_options_NPdataFile_get;
*swig_NPdataFile_set = *Lingua::FreeLing3::Bindingsc::maco_options_NPdataFile_set;
*swig_PunctuationFile_get = *Lingua::FreeLing3::Bindingsc::maco_options_PunctuationFile_get;
*swig_PunctuationFile_set = *Lingua::FreeLing3::Bindingsc::maco_options_PunctuationFile_set;
*swig_UserMapFile_get = *Lingua::FreeLing3::Bindingsc::maco_options_UserMapFile_get;
*swig_UserMapFile_set = *Lingua::FreeLing3::Bindingsc::maco_options_UserMapFile_set;
*swig_Decimal_get = *Lingua::FreeLing3::Bindingsc::maco_options_Decimal_get;
*swig_Decimal_set = *Lingua::FreeLing3::Bindingsc::maco_options_Decimal_set;
*swig_Thousand_get = *Lingua::FreeLing3::Bindingsc::maco_options_Thousand_get;
*swig_Thousand_set = *Lingua::FreeLing3::Bindingsc::maco_options_Thousand_set;
*swig_ProbabilityThreshold_get = *Lingua::FreeLing3::Bindingsc::maco_options_ProbabilityThreshold_get;
*swig_ProbabilityThreshold_set = *Lingua::FreeLing3::Bindingsc::maco_options_ProbabilityThreshold_set;
*swig_InverseDict_get = *Lingua::FreeLing3::Bindingsc::maco_options_InverseDict_get;
*swig_InverseDict_set = *Lingua::FreeLing3::Bindingsc::maco_options_InverseDict_set;
*swig_RetokContractions_get = *Lingua::FreeLing3::Bindingsc::maco_options_RetokContractions_get;
*swig_RetokContractions_set = *Lingua::FreeLing3::Bindingsc::maco_options_RetokContractions_set;
sub new {
    my $pkg = shift;
    my $self = Lingua::FreeLing3::Bindingsc::new_maco_options(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Lingua::FreeLing3::Bindingsc::delete_maco_options($self);
        delete $OWNER{$self};
    }
}

*set_active_modules = *Lingua::FreeLing3::Bindingsc::maco_options_set_active_modules;
*set_data_files = *Lingua::FreeLing3::Bindingsc::maco_options_set_data_files;
*set_nummerical_points = *Lingua::FreeLing3::Bindingsc::maco_options_set_nummerical_points;
*set_threshold = *Lingua::FreeLing3::Bindingsc::maco_options_set_threshold;
*set_inverse_dict = *Lingua::FreeLing3::Bindingsc::maco_options_set_inverse_dict;
*set_retok_contractions = *Lingua::FreeLing3::Bindingsc::maco_options_set_retok_contractions;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Lingua::FreeLing3::Bindings::maco ##############

package Lingua::FreeLing3::Bindings::maco;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Lingua::FreeLing3::Bindings );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Lingua::FreeLing3::Bindingsc::new_maco(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Lingua::FreeLing3::Bindingsc::delete_maco($self);
        delete $OWNER{$self};
    }
}

*analyze = *Lingua::FreeLing3::Bindingsc::maco_analyze;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Lingua::FreeLing3::Bindings::RE_map ##############

package Lingua::FreeLing3::Bindings::RE_map;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Lingua::FreeLing3::Bindings );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Lingua::FreeLing3::Bindingsc::new_RE_map(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Lingua::FreeLing3::Bindingsc::delete_RE_map($self);
        delete $OWNER{$self};
    }
}

*annotate_word = *Lingua::FreeLing3::Bindingsc::RE_map_annotate_word;
*analyze = *Lingua::FreeLing3::Bindingsc::RE_map_analyze;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Lingua::FreeLing3::Bindings::numbers ##############

package Lingua::FreeLing3::Bindings::numbers;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Lingua::FreeLing3::Bindings );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Lingua::FreeLing3::Bindingsc::new_numbers(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Lingua::FreeLing3::Bindingsc::delete_numbers($self);
        delete $OWNER{$self};
    }
}

*analyze = *Lingua::FreeLing3::Bindingsc::numbers_analyze;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Lingua::FreeLing3::Bindings::punts ##############

package Lingua::FreeLing3::Bindings::punts;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Lingua::FreeLing3::Bindings );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Lingua::FreeLing3::Bindingsc::new_punts(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Lingua::FreeLing3::Bindingsc::delete_punts($self);
        delete $OWNER{$self};
    }
}

*analyze = *Lingua::FreeLing3::Bindingsc::punts_analyze;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Lingua::FreeLing3::Bindings::dates ##############

package Lingua::FreeLing3::Bindings::dates;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Lingua::FreeLing3::Bindings );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Lingua::FreeLing3::Bindingsc::new_dates(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Lingua::FreeLing3::Bindingsc::delete_dates($self);
        delete $OWNER{$self};
    }
}

*analyze = *Lingua::FreeLing3::Bindingsc::dates_analyze;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Lingua::FreeLing3::Bindings::dictionary ##############

package Lingua::FreeLing3::Bindings::dictionary;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Lingua::FreeLing3::Bindings );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Lingua::FreeLing3::Bindingsc::new_dictionary(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Lingua::FreeLing3::Bindingsc::delete_dictionary($self);
        delete $OWNER{$self};
    }
}

*add_analysis = *Lingua::FreeLing3::Bindingsc::dictionary_add_analysis;
*remove_entry = *Lingua::FreeLing3::Bindingsc::dictionary_remove_entry;
*search_form = *Lingua::FreeLing3::Bindingsc::dictionary_search_form;
*annotate_word = *Lingua::FreeLing3::Bindingsc::dictionary_annotate_word;
*get_forms = *Lingua::FreeLing3::Bindingsc::dictionary_get_forms;
*analyze = *Lingua::FreeLing3::Bindingsc::dictionary_analyze;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Lingua::FreeLing3::Bindings::locutions ##############

package Lingua::FreeLing3::Bindings::locutions;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Lingua::FreeLing3::Bindings );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Lingua::FreeLing3::Bindingsc::new_locutions(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Lingua::FreeLing3::Bindingsc::delete_locutions($self);
        delete $OWNER{$self};
    }
}

*add_locution = *Lingua::FreeLing3::Bindingsc::locutions_add_locution;
*analyze = *Lingua::FreeLing3::Bindingsc::locutions_analyze;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Lingua::FreeLing3::Bindings::ner ##############

package Lingua::FreeLing3::Bindings::ner;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Lingua::FreeLing3::Bindings );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Lingua::FreeLing3::Bindingsc::new_ner(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Lingua::FreeLing3::Bindingsc::delete_ner($self);
        delete $OWNER{$self};
    }
}

*analyze = *Lingua::FreeLing3::Bindingsc::ner_analyze;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Lingua::FreeLing3::Bindings::quantities ##############

package Lingua::FreeLing3::Bindings::quantities;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Lingua::FreeLing3::Bindings );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Lingua::FreeLing3::Bindingsc::new_quantities(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Lingua::FreeLing3::Bindingsc::delete_quantities($self);
        delete $OWNER{$self};
    }
}

*analyze = *Lingua::FreeLing3::Bindingsc::quantities_analyze;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Lingua::FreeLing3::Bindings::probabilities ##############

package Lingua::FreeLing3::Bindings::probabilities;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Lingua::FreeLing3::Bindings );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Lingua::FreeLing3::Bindingsc::new_probabilities(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Lingua::FreeLing3::Bindingsc::delete_probabilities($self);
        delete $OWNER{$self};
    }
}

*annotate_word = *Lingua::FreeLing3::Bindingsc::probabilities_annotate_word;
*set_activate_guesser = *Lingua::FreeLing3::Bindingsc::probabilities_set_activate_guesser;
*analyze = *Lingua::FreeLing3::Bindingsc::probabilities_analyze;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Lingua::FreeLing3::Bindings::hmm_tagger ##############

package Lingua::FreeLing3::Bindings::hmm_tagger;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Lingua::FreeLing3::Bindings );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Lingua::FreeLing3::Bindingsc::new_hmm_tagger(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Lingua::FreeLing3::Bindingsc::delete_hmm_tagger($self);
        delete $OWNER{$self};
    }
}

*SequenceProb_log = *Lingua::FreeLing3::Bindingsc::hmm_tagger_SequenceProb_log;
*analyze = *Lingua::FreeLing3::Bindingsc::hmm_tagger_analyze;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Lingua::FreeLing3::Bindings::relax_tagger ##############

package Lingua::FreeLing3::Bindings::relax_tagger;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Lingua::FreeLing3::Bindings );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Lingua::FreeLing3::Bindingsc::new_relax_tagger(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Lingua::FreeLing3::Bindingsc::delete_relax_tagger($self);
        delete $OWNER{$self};
    }
}

*analyze = *Lingua::FreeLing3::Bindingsc::relax_tagger_analyze;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Lingua::FreeLing3::Bindings::alternatives ##############

package Lingua::FreeLing3::Bindings::alternatives;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Lingua::FreeLing3::Bindings );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Lingua::FreeLing3::Bindingsc::new_alternatives(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Lingua::FreeLing3::Bindingsc::delete_alternatives($self);
        delete $OWNER{$self};
    }
}

*get_similar_words = *Lingua::FreeLing3::Bindingsc::alternatives_get_similar_words;
*analyze = *Lingua::FreeLing3::Bindingsc::alternatives_analyze;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Lingua::FreeLing3::Bindings::phonetics ##############

package Lingua::FreeLing3::Bindings::phonetics;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Lingua::FreeLing3::Bindings );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Lingua::FreeLing3::Bindingsc::new_phonetics(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Lingua::FreeLing3::Bindingsc::delete_phonetics($self);
        delete $OWNER{$self};
    }
}

*get_sound = *Lingua::FreeLing3::Bindingsc::phonetics_get_sound;
*analyze = *Lingua::FreeLing3::Bindingsc::phonetics_analyze;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Lingua::FreeLing3::Bindings::nec ##############

package Lingua::FreeLing3::Bindings::nec;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Lingua::FreeLing3::Bindings );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Lingua::FreeLing3::Bindingsc::new_nec(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Lingua::FreeLing3::Bindingsc::delete_nec($self);
        delete $OWNER{$self};
    }
}

*analyze = *Lingua::FreeLing3::Bindingsc::nec_analyze;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Lingua::FreeLing3::Bindings::chart_parser ##############

package Lingua::FreeLing3::Bindings::chart_parser;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Lingua::FreeLing3::Bindings );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Lingua::FreeLing3::Bindingsc::new_chart_parser(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Lingua::FreeLing3::Bindingsc::delete_chart_parser($self);
        delete $OWNER{$self};
    }
}

*get_start_symbol = *Lingua::FreeLing3::Bindingsc::chart_parser_get_start_symbol;
*analyze = *Lingua::FreeLing3::Bindingsc::chart_parser_analyze;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Lingua::FreeLing3::Bindings::dep_txala ##############

package Lingua::FreeLing3::Bindings::dep_txala;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Lingua::FreeLing3::Bindings );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Lingua::FreeLing3::Bindingsc::new_dep_txala(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Lingua::FreeLing3::Bindingsc::delete_dep_txala($self);
        delete $OWNER{$self};
    }
}

*analyze = *Lingua::FreeLing3::Bindingsc::dep_txala_analyze;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Lingua::FreeLing3::Bindings::senses ##############

package Lingua::FreeLing3::Bindings::senses;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Lingua::FreeLing3::Bindings );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Lingua::FreeLing3::Bindingsc::new_senses(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Lingua::FreeLing3::Bindingsc::delete_senses($self);
        delete $OWNER{$self};
    }
}

*analyze = *Lingua::FreeLing3::Bindingsc::senses_analyze;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Lingua::FreeLing3::Bindings::ukb ##############

package Lingua::FreeLing3::Bindings::ukb;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Lingua::FreeLing3::Bindings );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Lingua::FreeLing3::Bindingsc::new_ukb(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Lingua::FreeLing3::Bindingsc::delete_ukb($self);
        delete $OWNER{$self};
    }
}

*analyze = *Lingua::FreeLing3::Bindingsc::ukb_analyze;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Lingua::FreeLing3::Bindings::sense_info ##############

package Lingua::FreeLing3::Bindings::sense_info;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Lingua::FreeLing3::Bindings );
%OWNER = ();
%ITERATORS = ();
*swig_sense_get = *Lingua::FreeLing3::Bindingsc::sense_info_sense_get;
*swig_sense_set = *Lingua::FreeLing3::Bindingsc::sense_info_sense_set;
*swig_parents_get = *Lingua::FreeLing3::Bindingsc::sense_info_parents_get;
*swig_parents_set = *Lingua::FreeLing3::Bindingsc::sense_info_parents_set;
*swig_semfile_get = *Lingua::FreeLing3::Bindingsc::sense_info_semfile_get;
*swig_semfile_set = *Lingua::FreeLing3::Bindingsc::sense_info_semfile_set;
*swig_words_get = *Lingua::FreeLing3::Bindingsc::sense_info_words_get;
*swig_words_set = *Lingua::FreeLing3::Bindingsc::sense_info_words_set;
*swig_tonto_get = *Lingua::FreeLing3::Bindingsc::sense_info_tonto_get;
*swig_tonto_set = *Lingua::FreeLing3::Bindingsc::sense_info_tonto_set;
sub new {
    my $pkg = shift;
    my $self = Lingua::FreeLing3::Bindingsc::new_sense_info(@_);
    bless $self, $pkg if defined($self);
}

*get_parents_string = *Lingua::FreeLing3::Bindingsc::sense_info_get_parents_string;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Lingua::FreeLing3::Bindingsc::delete_sense_info($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Lingua::FreeLing3::Bindings::semanticDB ##############

package Lingua::FreeLing3::Bindings::semanticDB;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Lingua::FreeLing3::Bindings );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Lingua::FreeLing3::Bindingsc::new_semanticDB(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Lingua::FreeLing3::Bindingsc::delete_semanticDB($self);
        delete $OWNER{$self};
    }
}

*get_WN_keys = *Lingua::FreeLing3::Bindingsc::semanticDB_get_WN_keys;
*get_sense_words = *Lingua::FreeLing3::Bindingsc::semanticDB_get_sense_words;
*get_word_senses = *Lingua::FreeLing3::Bindingsc::semanticDB_get_word_senses;
*get_sense_info = *Lingua::FreeLing3::Bindingsc::semanticDB_get_sense_info;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Lingua::FreeLing3::Bindings::tagset ##############

package Lingua::FreeLing3::Bindings::tagset;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Lingua::FreeLing3::Bindings );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Lingua::FreeLing3::Bindingsc::new_tagset(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Lingua::FreeLing3::Bindingsc::delete_tagset($self);
        delete $OWNER{$self};
    }
}

*get_short_tag = *Lingua::FreeLing3::Bindingsc::tagset_get_short_tag;
*get_msf_features = *Lingua::FreeLing3::Bindingsc::tagset_get_msf_features;
*get_msf_string = *Lingua::FreeLing3::Bindingsc::tagset_get_msf_string;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Lingua::FreeLing3::Bindings::foma_FSM ##############

package Lingua::FreeLing3::Bindings::foma_FSM;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Lingua::FreeLing3::Bindings );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Lingua::FreeLing3::Bindingsc::new_foma_FSM(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Lingua::FreeLing3::Bindingsc::delete_foma_FSM($self);
        delete $OWNER{$self};
    }
}

*get_similar_words = *Lingua::FreeLing3::Bindingsc::foma_FSM_get_similar_words;
*set_cutoff_threshold = *Lingua::FreeLing3::Bindingsc::foma_FSM_set_cutoff_threshold;
*set_num_matches = *Lingua::FreeLing3::Bindingsc::foma_FSM_set_num_matches;
*set_basic_operation_cost = *Lingua::FreeLing3::Bindingsc::foma_FSM_set_basic_operation_cost;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Lingua::FreeLing3::Bindings::util ##############

package Lingua::FreeLing3::Bindings::util;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Lingua::FreeLing3::Bindings );
%OWNER = ();
%ITERATORS = ();
*init_locale = *Lingua::FreeLing3::Bindingsc::util_init_locale;
*wstring2int = *Lingua::FreeLing3::Bindingsc::util_wstring2int;
*int2wstring = *Lingua::FreeLing3::Bindingsc::util_int2wstring;
*wstring2double = *Lingua::FreeLing3::Bindingsc::util_wstring2double;
*double2wstring = *Lingua::FreeLing3::Bindingsc::util_double2wstring;
*wstring2longdouble = *Lingua::FreeLing3::Bindingsc::util_wstring2longdouble;
*longdouble2wstring = *Lingua::FreeLing3::Bindingsc::util_longdouble2wstring;
*vector2wstring = *Lingua::FreeLing3::Bindingsc::util_vector2wstring;
*list2wstring = *Lingua::FreeLing3::Bindingsc::util_list2wstring;
*pairlist2wstring = *Lingua::FreeLing3::Bindingsc::util_pairlist2wstring;
*wstring2list = *Lingua::FreeLing3::Bindingsc::util_wstring2list;
*wstring2vector = *Lingua::FreeLing3::Bindingsc::util_wstring2vector;
sub new {
    my $pkg = shift;
    my $self = Lingua::FreeLing3::Bindingsc::new_util(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Lingua::FreeLing3::Bindingsc::delete_util($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


# ------- VARIABLE STUBS --------

package Lingua::FreeLing3::Bindings;

*traces_TraceLevel = *Lingua::FreeLing3::Bindingsc::traces_TraceLevel;
*traces_TraceModule = *Lingua::FreeLing3::Bindingsc::traces_TraceModule;



__END__

=encoding utf8

=head1 NAME

 Lingua::FreeLing2::Bindings - Bindings to FreeLing library.

=head1 DESCRIPTION

This module is the base for the bindings between Perl and the C++
library, FreeLing. It was generated by Jorge Cunha Mendes, using as
base the module provided in the FreeLing distribution.

Given the high amount of modules and methods, the bindings are not
practical to be used directly. Therefore, C<Lingua::FreeLing>
encapsulates the binding behavior in more Perlish interfaces.

Please refer to L<Lingua::FreeLing> for the documentation table of
contents, and try not to use this module directly. You can always
request the authors an interface to any of these methods to be added
in the main modules.

=head1 SEE ALSO

Lingua::FreeLing2(3) for the documentation table of contents. The
freeling library for extra information, or perl(1) itself.

=head1 AUTHOR

Lluís Padró

=head1 COPYRIGHT AND LICENSE

Copyright (C) 2011-2013 by Projecto Natura

=cut

1;
